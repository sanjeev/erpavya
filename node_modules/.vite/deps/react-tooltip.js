import {
  arrow,
  autoUpdate,
  computePosition,
  flip,
  offset,
  shift
} from "./chunk-SIWZF7S4.js";
import {
  require_react
} from "./chunk-HS5T2ZWL.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/react-tooltip/node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/react-tooltip/node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      var nativeCodeString = "[native code]";
      function classNames() {
        var classes = [];
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/react-tooltip/dist/react-tooltip.min.mjs
var import_react = __toESM(require_react(), 1);
var import_classnames = __toESM(require_classnames(), 1);
var f = "react-tooltip-core-styles";
var h = "react-tooltip-base-styles";
var w = { core: false, base: false };
function b({ css: e2, id: t2 = h, type: r2 = "base", ref: o2 }) {
  var n2, l2;
  if (!e2 || "undefined" == typeof document || w[r2])
    return;
  if ("core" === r2 && "undefined" != typeof process && (null === (n2 = null === process || void 0 === process ? void 0 : process.env) || void 0 === n2 ? void 0 : n2.REACT_TOOLTIP_DISABLE_CORE_STYLES))
    return;
  if ("base" !== r2 && "undefined" != typeof process && (null === (l2 = null === process || void 0 === process ? void 0 : process.env) || void 0 === l2 ? void 0 : l2.REACT_TOOLTIP_DISABLE_BASE_STYLES))
    return;
  "core" === r2 && (t2 = f), o2 || (o2 = {});
  const { insertAt: i2 } = o2;
  if (document.getElementById(t2))
    return void console.warn(`[react-tooltip] Element with id '${t2}' already exists. Call \`removeStyle()\` first`);
  const c2 = document.head || document.getElementsByTagName("head")[0], a2 = document.createElement("style");
  a2.id = t2, a2.type = "text/css", "top" === i2 && c2.firstChild ? c2.insertBefore(a2, c2.firstChild) : c2.appendChild(a2), a2.styleSheet ? a2.styleSheet.cssText = e2 : a2.appendChild(document.createTextNode(e2)), w[r2] = true;
}
function S({ type: e2 = "base", id: t2 = h } = {}) {
  if (!w[e2])
    return;
  "core" === e2 && (t2 = f);
  const r2 = document.getElementById(t2);
  "style" === (null == r2 ? void 0 : r2.tagName) ? null == r2 || r2.remove() : console.warn(`[react-tooltip] Failed to remove 'style' element with id '${t2}'. Call \`injectStyle()\` first`), w[e2] = false;
}
var E = (e2, t2, r2) => {
  let o2 = null;
  return function(...n2) {
    const l2 = () => {
      o2 = null, r2 || e2.apply(this, n2);
    };
    r2 && !o2 && (e2.apply(this, n2), o2 = setTimeout(l2, t2)), r2 || (o2 && clearTimeout(o2), o2 = setTimeout(l2, t2));
  };
};
var _ = "DEFAULT_TOOLTIP_ID";
var g = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} };
var A = (0, import_react.createContext)({ getTooltipData: () => g });
var T = ({ children: t2 }) => {
  const [l2, i2] = (0, import_react.useState)({ [_]: /* @__PURE__ */ new Set() }), [c2, a2] = (0, import_react.useState)({ [_]: { current: null } }), s = (e2, ...t3) => {
    i2((r2) => {
      var o2;
      const n2 = null !== (o2 = r2[e2]) && void 0 !== o2 ? o2 : /* @__PURE__ */ new Set();
      return t3.forEach((e3) => n2.add(e3)), { ...r2, [e2]: new Set(n2) };
    });
  }, u = (e2, ...t3) => {
    i2((r2) => {
      const o2 = r2[e2];
      return o2 ? (t3.forEach((e3) => o2.delete(e3)), { ...r2 }) : r2;
    });
  }, d = (0, import_react.useCallback)((e2 = _) => {
    var t3, r2;
    return { anchorRefs: null !== (t3 = l2[e2]) && void 0 !== t3 ? t3 : /* @__PURE__ */ new Set(), activeAnchor: null !== (r2 = c2[e2]) && void 0 !== r2 ? r2 : { current: null }, attach: (...t4) => s(e2, ...t4), detach: (...t4) => u(e2, ...t4), setActiveAnchor: (t4) => ((e3, t5) => {
      a2((r3) => {
        var o2;
        return (null === (o2 = r3[e3]) || void 0 === o2 ? void 0 : o2.current) === t5.current ? r3 : { ...r3, [e3]: t5 };
      });
    })(e2, t4) };
  }, [l2, c2, s, u]), p = (0, import_react.useMemo)(() => ({ getTooltipData: d }), [d]);
  return import_react.default.createElement(A.Provider, { value: p }, t2);
};
function O(e2 = _) {
  return (0, import_react.useContext)(A).getTooltipData(e2);
}
var L = ({ tooltipId: t2, children: r2, className: o2, place: n2, content: l2, html: a2, variant: s, offset: u, wrapper: d, events: p, positionStrategy: v, delayShow: m, delayHide: f2 }) => {
  const { attach: h2, detach: w2 } = O(t2), b2 = (0, import_react.useRef)(null);
  return (0, import_react.useEffect)(() => (h2(b2), () => {
    w2(b2);
  }), []), import_react.default.createElement("span", { ref: b2, className: (0, import_classnames.default)("react-tooltip-wrapper", o2), "data-tooltip-place": n2, "data-tooltip-content": l2, "data-tooltip-html": a2, "data-tooltip-variant": s, "data-tooltip-offset": u, "data-tooltip-wrapper": d, "data-tooltip-events": p, "data-tooltip-position-strategy": v, "data-tooltip-delay-show": m, "data-tooltip-delay-hide": f2 }, r2);
};
var R = "undefined" != typeof window ? import_react.useLayoutEffect : import_react.useEffect;
var N = (e2) => {
  if (!(e2 instanceof HTMLElement || e2 instanceof SVGElement))
    return false;
  const t2 = getComputedStyle(e2);
  return ["overflow", "overflow-x", "overflow-y"].some((e3) => {
    const r2 = t2.getPropertyValue(e3);
    return "auto" === r2 || "scroll" === r2;
  });
};
var k = (e2) => {
  if (!e2)
    return null;
  let t2 = e2.parentElement;
  for (; t2; ) {
    if (N(t2))
      return t2;
    t2 = t2.parentElement;
  }
  return document.scrollingElement || document.documentElement;
};
var x = async ({ elementReference: e2 = null, tooltipReference: t2 = null, tooltipArrowReference: r2 = null, place: o2 = "top", offset: n2 = 10, strategy: l2 = "absolute", middlewares: i2 = [offset(Number(n2)), flip(), shift({ padding: 5 })], border: c2 }) => {
  if (!e2)
    return { tooltipStyles: {}, tooltipArrowStyles: {}, place: o2 };
  if (null === t2)
    return { tooltipStyles: {}, tooltipArrowStyles: {}, place: o2 };
  const a2 = i2;
  return r2 ? (a2.push(arrow({ element: r2, padding: 5 })), computePosition(e2, t2, { placement: o2, strategy: l2, middleware: a2 }).then(({ x: e3, y: t3, placement: r3, middlewareData: o3 }) => {
    var n3, l3;
    const i3 = { left: `${e3}px`, top: `${t3}px`, border: c2 }, { x: a3, y: s } = null !== (n3 = o3.arrow) && void 0 !== n3 ? n3 : { x: 0, y: 0 }, u = null !== (l3 = { top: "bottom", right: "left", bottom: "top", left: "right" }[r3.split("-")[0]]) && void 0 !== l3 ? l3 : "bottom", d = c2 && { borderBottom: c2, borderRight: c2 };
    let p = 0;
    if (c2) {
      const e4 = `${c2}`.match(/(\d+)px/);
      p = (null == e4 ? void 0 : e4[1]) ? Number(e4[1]) : 1;
    }
    return { tooltipStyles: i3, tooltipArrowStyles: { left: null != a3 ? `${a3}px` : "", top: null != s ? `${s}px` : "", right: "", bottom: "", ...d, [u]: `-${4 + p}px` }, place: r3 };
  })) : computePosition(e2, t2, { placement: "bottom", strategy: l2, middleware: a2 }).then(({ x: e3, y: t3, placement: r3 }) => ({ tooltipStyles: { left: `${e3}px`, top: `${t3}px` }, tooltipArrowStyles: {}, place: r3 }));
};
var C = "core-styles-module_tooltip__3vRRp";
var $ = "core-styles-module_fixed__pcSol";
var I = "core-styles-module_arrow__cvMwQ";
var j = "core-styles-module_noArrow__xock6";
var B = "core-styles-module_clickable__ZuTTB";
var D = "core-styles-module_show__Nt9eE";
var H = { tooltip: "styles-module_tooltip__mnnfp", arrow: "styles-module_arrow__K0L3T", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
var z = ({ id: t2, className: n2, classNameArrow: l2, variant: a2 = "dark", anchorId: s, anchorSelect: u, place: d = "top", offset: p = 10, events: v = ["hover"], openOnClick: f2 = false, positionStrategy: h2 = "absolute", middlewares: w2, wrapper: b2, delayShow: S2 = 0, delayHide: _2 = 0, float: g2 = false, hidden: A2 = false, noArrow: T2 = false, clickable: L2 = false, closeOnEsc: N2 = false, closeOnScroll: z2 = false, closeOnResize: q2 = false, style: W2, position: M, afterShow: P, afterHide: F, content: K, contentWrapperRef: U, isOpen: X, setIsOpen: Y, activeAnchor: V, setActiveAnchor: Z, border: G, opacity: J, arrowColor: Q }) => {
  const ee = (0, import_react.useRef)(null), te = (0, import_react.useRef)(null), re = (0, import_react.useRef)(null), oe = (0, import_react.useRef)(null), [ne, le] = (0, import_react.useState)(d), [ie, ce] = (0, import_react.useState)({}), [ae, se] = (0, import_react.useState)({}), [ue, de] = (0, import_react.useState)(false), [pe, ve] = (0, import_react.useState)(false), me = (0, import_react.useRef)(false), ye = (0, import_react.useRef)(null), { anchorRefs: fe, setActiveAnchor: he } = O(t2), we = (0, import_react.useRef)(false), [be, Se] = (0, import_react.useState)([]), Ee = (0, import_react.useRef)(false), _e = f2 || v.includes("click");
  R(() => (Ee.current = true, () => {
    Ee.current = false;
  }), []), (0, import_react.useEffect)(() => {
    if (!ue) {
      const e2 = setTimeout(() => {
        ve(false);
      }, 150);
      return () => {
        clearTimeout(e2);
      };
    }
    return () => null;
  }, [ue]);
  const ge = (e2) => {
    Ee.current && (e2 && ve(true), setTimeout(() => {
      Ee.current && (null == Y || Y(e2), void 0 === X && de(e2));
    }, 10));
  };
  (0, import_react.useEffect)(() => {
    if (void 0 === X)
      return () => null;
    X && ve(true);
    const e2 = setTimeout(() => {
      de(X);
    }, 10);
    return () => {
      clearTimeout(e2);
    };
  }, [X]), (0, import_react.useEffect)(() => {
    ue !== me.current && (me.current = ue, ue ? null == P || P() : null == F || F());
  }, [ue]);
  const Ae = (e2 = _2) => {
    oe.current && clearTimeout(oe.current), oe.current = setTimeout(() => {
      we.current || ge(false);
    }, e2);
  }, Te = (e2) => {
    var t3;
    if (!e2)
      return;
    const r2 = null !== (t3 = e2.currentTarget) && void 0 !== t3 ? t3 : e2.target;
    if (!(null == r2 ? void 0 : r2.isConnected))
      return Z(null), void he({ current: null });
    S2 ? (re.current && clearTimeout(re.current), re.current = setTimeout(() => {
      ge(true);
    }, S2)) : ge(true), Z(r2), he({ current: r2 }), oe.current && clearTimeout(oe.current);
  }, Oe = () => {
    L2 ? Ae(_2 || 100) : _2 ? Ae() : ge(false), re.current && clearTimeout(re.current);
  }, Le = ({ x: e2, y: t3 }) => {
    x({ place: d, offset: p, elementReference: { getBoundingClientRect: () => ({ x: e2, y: t3, width: 0, height: 0, top: t3, left: e2, right: e2, bottom: t3 }) }, tooltipReference: ee.current, tooltipArrowReference: te.current, strategy: h2, middlewares: w2, border: G }).then((e3) => {
      Object.keys(e3.tooltipStyles).length && ce(e3.tooltipStyles), Object.keys(e3.tooltipArrowStyles).length && se(e3.tooltipArrowStyles), le(e3.place);
    });
  }, Re = (e2) => {
    if (!e2)
      return;
    const t3 = e2, r2 = { x: t3.clientX, y: t3.clientY };
    Le(r2), ye.current = r2;
  }, Ne = (e2) => {
    Te(e2), _2 && Ae();
  }, ke = (e2) => {
    var t3;
    [document.querySelector(`[id='${s}']`), ...be].some((t4) => null == t4 ? void 0 : t4.contains(e2.target)) || (null === (t3 = ee.current) || void 0 === t3 ? void 0 : t3.contains(e2.target)) || (ge(false), re.current && clearTimeout(re.current));
  }, xe = E(Te, 50, true), Ce = E(Oe, 50, true), $e = (0, import_react.useCallback)(() => {
    M ? Le(M) : g2 ? ye.current && Le(ye.current) : x({ place: d, offset: p, elementReference: V, tooltipReference: ee.current, tooltipArrowReference: te.current, strategy: h2, middlewares: w2, border: G }).then((e2) => {
      Ee.current && (Object.keys(e2.tooltipStyles).length && ce(e2.tooltipStyles), Object.keys(e2.tooltipArrowStyles).length && se(e2.tooltipArrowStyles), le(e2.place));
    });
  }, [ue, V, K, W2, d, p, h2, M, g2]);
  (0, import_react.useEffect)(() => {
    var e2, t3;
    const r2 = new Set(fe);
    be.forEach((e3) => {
      r2.add({ current: e3 });
    });
    const o2 = document.querySelector(`[id='${s}']`);
    o2 && r2.add({ current: o2 });
    const n3 = () => {
      ge(false);
    }, l3 = k(V), i2 = k(ee.current);
    z2 && (window.addEventListener("scroll", n3), null == l3 || l3.addEventListener("scroll", n3), null == i2 || i2.addEventListener("scroll", n3));
    let c2 = null;
    q2 ? window.addEventListener("resize", n3) : V && ee.current && (c2 = autoUpdate(V, ee.current, $e, { ancestorResize: true, elementResize: true, layoutShift: true }));
    const a3 = (e3) => {
      "Escape" === e3.key && ge(false);
    };
    N2 && window.addEventListener("keydown", a3);
    const u2 = [];
    _e ? (window.addEventListener("click", ke), u2.push({ event: "click", listener: Ne })) : (u2.push({ event: "mouseenter", listener: xe }, { event: "mouseleave", listener: Ce }, { event: "focus", listener: xe }, { event: "blur", listener: Ce }), g2 && u2.push({ event: "mousemove", listener: Re }));
    const d2 = () => {
      we.current = true;
    }, p2 = () => {
      we.current = false, Oe();
    };
    return L2 && !_e && (null === (e2 = ee.current) || void 0 === e2 || e2.addEventListener("mouseenter", d2), null === (t3 = ee.current) || void 0 === t3 || t3.addEventListener("mouseleave", p2)), u2.forEach(({ event: e3, listener: t4 }) => {
      r2.forEach((r3) => {
        var o3;
        null === (o3 = r3.current) || void 0 === o3 || o3.addEventListener(e3, t4);
      });
    }), () => {
      var e3, t4;
      z2 && (window.removeEventListener("scroll", n3), null == l3 || l3.removeEventListener("scroll", n3), null == i2 || i2.removeEventListener("scroll", n3)), q2 ? window.removeEventListener("resize", n3) : null == c2 || c2(), _e && window.removeEventListener("click", ke), N2 && window.removeEventListener("keydown", a3), L2 && !_e && (null === (e3 = ee.current) || void 0 === e3 || e3.removeEventListener("mouseenter", d2), null === (t4 = ee.current) || void 0 === t4 || t4.removeEventListener("mouseleave", p2)), u2.forEach(({ event: e4, listener: t5 }) => {
        r2.forEach((r3) => {
          var o3;
          null === (o3 = r3.current) || void 0 === o3 || o3.removeEventListener(e4, t5);
        });
      });
    };
  }, [V, $e, pe, fe, be, N2, v]), (0, import_react.useEffect)(() => {
    let e2 = null != u ? u : "";
    !e2 && t2 && (e2 = `[data-tooltip-id='${t2}']`);
    const r2 = new MutationObserver((r3) => {
      const o2 = [];
      r3.forEach((r4) => {
        if ("attributes" === r4.type && "data-tooltip-id" === r4.attributeName) {
          r4.target.getAttribute("data-tooltip-id") === t2 && o2.push(r4.target);
        }
        if ("childList" === r4.type && (V && [...r4.removedNodes].some((e3) => {
          var t3;
          return !!(null === (t3 = null == e3 ? void 0 : e3.contains) || void 0 === t3 ? void 0 : t3.call(e3, V)) && (ve(false), ge(false), Z(null), re.current && clearTimeout(re.current), oe.current && clearTimeout(oe.current), true);
        }), e2))
          try {
            const t3 = [...r4.addedNodes].filter((e3) => 1 === e3.nodeType);
            o2.push(...t3.filter((t4) => t4.matches(e2))), o2.push(...t3.flatMap((t4) => [...t4.querySelectorAll(e2)]));
          } catch (e3) {
          }
      }), o2.length && Se((e3) => [...e3, ...o2]);
    });
    return r2.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ["data-tooltip-id"] }), () => {
      r2.disconnect();
    };
  }, [t2, u, V]), (0, import_react.useEffect)(() => {
    $e();
  }, [$e]), (0, import_react.useEffect)(() => {
    if (!(null == U ? void 0 : U.current))
      return () => null;
    const e2 = new ResizeObserver(() => {
      $e();
    });
    return e2.observe(U.current), () => {
      e2.disconnect();
    };
  }, [K, null == U ? void 0 : U.current]), (0, import_react.useEffect)(() => {
    var e2;
    const t3 = document.querySelector(`[id='${s}']`), r2 = [...be, t3];
    V && r2.includes(V) || Z(null !== (e2 = be[0]) && void 0 !== e2 ? e2 : t3);
  }, [s, be, V]), (0, import_react.useEffect)(() => () => {
    re.current && clearTimeout(re.current), oe.current && clearTimeout(oe.current);
  }, []), (0, import_react.useEffect)(() => {
    let e2 = u;
    if (!e2 && t2 && (e2 = `[data-tooltip-id='${t2}']`), e2)
      try {
        const t3 = Array.from(document.querySelectorAll(e2));
        Se(t3);
      } catch (e3) {
        Se([]);
      }
  }, [t2, u]);
  const Ie = !A2 && K && ue && Object.keys(ie).length > 0;
  return pe ? import_react.default.createElement(b2, { id: t2, role: "tooltip", className: (0, import_classnames.default)("react-tooltip", C, H.tooltip, H[a2], n2, `react-tooltip__place-${ne}`, { "react-tooltip__show": Ie, [D]: Ie, [$]: "fixed" === h2, [B]: L2 }), style: { ...W2, ...ie, opacity: void 0 !== J && Ie ? J : void 0 }, ref: ee }, K, import_react.default.createElement(b2, { className: (0, import_classnames.default)("react-tooltip-arrow", I, H.arrow, l2, { [j]: T2 }), style: { ...ae, background: Q ? `linear-gradient(to right bottom, transparent 50%, ${Q} 50%)` : void 0 }, ref: te })) : null;
};
var q = ({ content: t2 }) => import_react.default.createElement("span", { dangerouslySetInnerHTML: { __html: t2 } });
var W = ({ id: t2, anchorId: o2, anchorSelect: n2, content: l2, html: a2, render: s, className: u, classNameArrow: d, variant: p = "dark", place: v = "top", offset: m = 10, wrapper: y2 = "div", children: f2 = null, events: h2 = ["hover"], openOnClick: w2 = false, positionStrategy: b2 = "absolute", middlewares: S2, delayShow: E2 = 0, delayHide: _2 = 0, float: g2 = false, hidden: A2 = false, noArrow: T2 = false, clickable: L2 = false, closeOnEsc: R2 = false, closeOnScroll: N2 = false, closeOnResize: k2 = false, style: x2, position: C2, isOpen: $2, disableStyleInjection: I2 = false, border: j2, opacity: B2, arrowColor: D2, setIsOpen: H2, afterShow: W2, afterHide: M }) => {
  const [P, F] = (0, import_react.useState)(l2), [K, U] = (0, import_react.useState)(a2), [X, Y] = (0, import_react.useState)(v), [V, Z] = (0, import_react.useState)(p), [G, J] = (0, import_react.useState)(m), [Q, ee] = (0, import_react.useState)(E2), [te, re] = (0, import_react.useState)(_2), [oe, ne] = (0, import_react.useState)(g2), [le, ie] = (0, import_react.useState)(A2), [ce, ae] = (0, import_react.useState)(y2), [se, ue] = (0, import_react.useState)(h2), [de, pe] = (0, import_react.useState)(b2), [ve, me] = (0, import_react.useState)(null), ye = (0, import_react.useRef)(I2), { anchorRefs: fe, activeAnchor: he } = O(t2), we = (e2) => null == e2 ? void 0 : e2.getAttributeNames().reduce((t3, r2) => {
    var o3;
    if (r2.startsWith("data-tooltip-")) {
      t3[r2.replace(/^data-tooltip-/, "")] = null !== (o3 = null == e2 ? void 0 : e2.getAttribute(r2)) && void 0 !== o3 ? o3 : null;
    }
    return t3;
  }, {}), be = (e2) => {
    const t3 = { place: (e3) => {
      var t4;
      Y(null !== (t4 = e3) && void 0 !== t4 ? t4 : v);
    }, content: (e3) => {
      F(null != e3 ? e3 : l2);
    }, html: (e3) => {
      U(null != e3 ? e3 : a2);
    }, variant: (e3) => {
      var t4;
      Z(null !== (t4 = e3) && void 0 !== t4 ? t4 : p);
    }, offset: (e3) => {
      J(null === e3 ? m : Number(e3));
    }, wrapper: (e3) => {
      var t4;
      ae(null !== (t4 = e3) && void 0 !== t4 ? t4 : y2);
    }, events: (e3) => {
      const t4 = null == e3 ? void 0 : e3.split(" ");
      ue(null != t4 ? t4 : h2);
    }, "position-strategy": (e3) => {
      var t4;
      pe(null !== (t4 = e3) && void 0 !== t4 ? t4 : b2);
    }, "delay-show": (e3) => {
      ee(null === e3 ? E2 : Number(e3));
    }, "delay-hide": (e3) => {
      re(null === e3 ? _2 : Number(e3));
    }, float: (e3) => {
      ne(null === e3 ? g2 : "true" === e3);
    }, hidden: (e3) => {
      ie(null === e3 ? A2 : "true" === e3);
    } };
    Object.values(t3).forEach((e3) => e3(null)), Object.entries(e2).forEach(([e3, r2]) => {
      var o3;
      null === (o3 = t3[e3]) || void 0 === o3 || o3.call(t3, r2);
    });
  };
  (0, import_react.useEffect)(() => {
    F(l2);
  }, [l2]), (0, import_react.useEffect)(() => {
    U(a2);
  }, [a2]), (0, import_react.useEffect)(() => {
    Y(v);
  }, [v]), (0, import_react.useEffect)(() => {
    Z(p);
  }, [p]), (0, import_react.useEffect)(() => {
    J(m);
  }, [m]), (0, import_react.useEffect)(() => {
    ee(E2);
  }, [E2]), (0, import_react.useEffect)(() => {
    re(_2);
  }, [_2]), (0, import_react.useEffect)(() => {
    ne(g2);
  }, [g2]), (0, import_react.useEffect)(() => {
    ie(A2);
  }, [A2]), (0, import_react.useEffect)(() => {
    pe(b2);
  }, [b2]), (0, import_react.useEffect)(() => {
    ye.current !== I2 && console.warn("[react-tooltip] Do not change `disableStyleInjection` dynamically.");
  }, [I2]), (0, import_react.useEffect)(() => {
    "undefined" != typeof window && window.dispatchEvent(new CustomEvent("react-tooltip-inject-styles", { detail: { disableCore: "core" === I2, disableBase: I2 } }));
  }, []), (0, import_react.useEffect)(() => {
    var e2;
    const r2 = new Set(fe);
    let l3 = n2;
    if (!l3 && t2 && (l3 = `[data-tooltip-id='${t2}']`), l3)
      try {
        document.querySelectorAll(l3).forEach((e3) => {
          r2.add({ current: e3 });
        });
      } catch (e3) {
        console.warn(`[react-tooltip] "${l3}" is not a valid CSS selector`);
      }
    const i2 = document.querySelector(`[id='${o2}']`);
    if (i2 && r2.add({ current: i2 }), !r2.size)
      return () => null;
    const c2 = null !== (e2 = null != ve ? ve : i2) && void 0 !== e2 ? e2 : he.current, a3 = new MutationObserver((e3) => {
      e3.forEach((e4) => {
        var t3;
        if (!c2 || "attributes" !== e4.type || !(null === (t3 = e4.attributeName) || void 0 === t3 ? void 0 : t3.startsWith("data-tooltip-")))
          return;
        const r3 = we(c2);
        be(r3);
      });
    }), s2 = { attributes: true, childList: false, subtree: false };
    if (c2) {
      const e3 = we(c2);
      be(e3), a3.observe(c2, s2);
    }
    return () => {
      a3.disconnect();
    };
  }, [fe, he, ve, o2, n2]), (0, import_react.useEffect)(() => {
    (null == x2 ? void 0 : x2.border) && console.warn("[react-tooltip] Do not set `style.border`. Use `border` prop instead."), j2 && !CSS.supports("border", `${j2}`) && console.warn(`[react-tooltip] "${j2}" is not a valid \`border\`.`), (null == x2 ? void 0 : x2.opacity) && console.warn("[react-tooltip] Do not set `style.opacity`. Use `opacity` prop instead."), B2 && !CSS.supports("opacity", `${B2}`) && console.warn(`[react-tooltip] "${B2}" is not a valid \`opacity\`.`);
  }, []);
  let Se = f2;
  const Ee = (0, import_react.useRef)(null);
  if (s) {
    const t3 = s({ content: null != P ? P : null, activeAnchor: ve });
    Se = t3 ? import_react.default.createElement("div", { ref: Ee, className: "react-tooltip-content-wrapper" }, t3) : null;
  } else
    P && (Se = P);
  K && (Se = import_react.default.createElement(q, { content: K }));
  const _e = { id: t2, anchorId: o2, anchorSelect: n2, className: u, classNameArrow: d, content: Se, contentWrapperRef: Ee, place: X, variant: V, offset: G, wrapper: ce, events: se, openOnClick: w2, positionStrategy: de, middlewares: S2, delayShow: Q, delayHide: te, float: oe, hidden: le, noArrow: T2, clickable: L2, closeOnEsc: R2, closeOnScroll: N2, closeOnResize: k2, style: x2, position: C2, isOpen: $2, border: j2, opacity: B2, arrowColor: D2, setIsOpen: H2, afterShow: W2, afterHide: M, activeAnchor: ve, setActiveAnchor: (e2) => me(e2) };
  return import_react.default.createElement(z, { ..._e });
};
"undefined" != typeof window && window.addEventListener("react-tooltip-inject-styles", (e2) => {
  e2.detail.disableCore || b({ css: `:root{--rt-color-white:#fff;--rt-color-dark:#222;--rt-color-success:#8dc572;--rt-color-error:#be6464;--rt-color-warning:#f0ad4e;--rt-color-info:#337ab7;--rt-opacity:0.9}.core-styles-module_tooltip__3vRRp{visibility:hidden;position:absolute;top:0;left:0;pointer-events:none;opacity:0;transition:opacity 0.3s ease-out;will-change:opacity,visibility}.core-styles-module_fixed__pcSol{position:fixed}.core-styles-module_arrow__cvMwQ{position:absolute;background:inherit}.core-styles-module_noArrow__xock6{display:none}.core-styles-module_clickable__ZuTTB{pointer-events:auto}.core-styles-module_show__Nt9eE{visibility:visible;opacity:var(--rt-opacity)}`, type: "core" }), e2.detail.disableBase || b({ css: `
.styles-module_tooltip__mnnfp{padding:8px 16px;border-radius:3px;font-size:90%;width:max-content}.styles-module_arrow__K0L3T{width:8px;height:8px}[class*='react-tooltip__place-top']>.styles-module_arrow__K0L3T{transform:rotate(45deg)}[class*='react-tooltip__place-right']>.styles-module_arrow__K0L3T{transform:rotate(135deg)}[class*='react-tooltip__place-bottom']>.styles-module_arrow__K0L3T{transform:rotate(225deg)}[class*='react-tooltip__place-left']>.styles-module_arrow__K0L3T{transform:rotate(315deg)}.styles-module_dark__xNqje{background:var(--rt-color-dark);color:var(--rt-color-white)}.styles-module_light__Z6W-X{background-color:var(--rt-color-white);color:var(--rt-color-dark)}.styles-module_success__A2AKt{background-color:var(--rt-color-success);color:var(--rt-color-white)}.styles-module_warning__SCK0X{background-color:var(--rt-color-warning);color:var(--rt-color-white)}.styles-module_error__JvumD{background-color:var(--rt-color-error);color:var(--rt-color-white)}.styles-module_info__BWdHW{background-color:var(--rt-color-info);color:var(--rt-color-white)}`, type: "base" });
});
export {
  W as Tooltip,
  T as TooltipProvider,
  L as TooltipWrapper,
  S as removeStyle
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

react-tooltip/dist/react-tooltip.min.mjs:
  (*
  * React Tooltip
  * {@link https://github.com/ReactTooltip/react-tooltip}
  * @copyright ReactTooltip Team
  * @license MIT
  *)
*/
//# sourceMappingURL=react-tooltip.js.map
